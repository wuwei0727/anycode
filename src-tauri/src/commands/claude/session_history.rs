use std::fs;
use std::io::{BufRead, BufReader, Seek, SeekFrom};
use std::path::Path;
use std::time::SystemTime;

use chrono::{DateTime, Utc};
use serde_json::Value;

use super::models::JsonlEntry;
use super::paths::get_claude_dir;

/// Session metadata extracted from JSONL file
/// Optimized to read file only once for head data, and seek to tail for last timestamp
#[derive(Debug, Default)]
pub struct SessionMetadata {
    pub first_message: Option<String>,
    pub message_timestamp: Option<String>,
    pub last_message_timestamp: Option<String>,
    pub model: Option<String>,
}

/// Extracts all session metadata in a single optimized pass
/// - Reads first ~100 lines for first_message and model
/// - Seeks to file tail for last_message_timestamp
pub fn extract_session_metadata<P: AsRef<Path>>(jsonl_path: P) -> SessionMetadata {
    let path = jsonl_path.as_ref();
    let mut metadata = SessionMetadata::default();
    
    // Open file once
    let file = match fs::File::open(path) {
        Ok(file) => file,
        Err(_) => return metadata,
    };
    
    let file_size = file.metadata().map(|m| m.len()).unwrap_or(0);
    let reader = BufReader::new(file);
    
    // Phase 1: Read first ~100 lines for first_message and model
    const MAX_LINES_FOR_HEAD: usize = 100;
    let mut line_count = 0;
    
    for line in reader.lines() {
        line_count += 1;
        if line_count > MAX_LINES_FOR_HEAD && metadata.first_message.is_some() {
            break;
        }
        
        if let Ok(line) = line {
            // Try to extract model from any line (model can appear early)
            if metadata.model.is_none() {
                if let Ok(entry) = serde_json::from_str::<Value>(&line) {
                    if let Some(model_str) = entry.get("model").and_then(|m| m.as_str()) {
                        metadata.model = Some(model_str.to_string());
                    } else if let Some(message) = entry.get("message") {
                        if let Some(model_str) = message.get("model").and_then(|m| m.as_str()) {
                            metadata.model = Some(model_str.to_string());
                        }
                    }
                }
            }
            
            // Extract first user message
            if metadata.first_message.is_none() {
                if let Ok(entry) = serde_json::from_str::<JsonlEntry>(&line) {
                    if let Some(message) = entry.message {
                        if message.role.as_deref() == Some("user") {
                            if let Some(content_value) = message.content {
                                let mut extracted_text = String::new();
                                let mut has_text_content = false;

                                if let Some(text) = content_value.as_str() {
                                    extracted_text = text.to_string();
                                    has_text_content = !text.trim().is_empty();
                                } else if let Some(arr) = content_value.as_array() {
                                    for item in arr {
                                        if let Some(item_type) = item.get("type").and_then(|t| t.as_str()) {
                                            if item_type == "text" {
                                                if let Some(text) = item.get("text").and_then(|t| t.as_str()) {
                                                    extracted_text.push_str(text);
                                                    has_text_content = true;
                                                }
                                            }
                                        }
                                    }
                                }

	                                if has_text_content {
	                                    // Skip system/warmup messages
	                                    if !extracted_text.contains("Caveat: The messages below were generated by the user while running local commands")
	                                        && !extracted_text.starts_with("<command-name>")
	                                        && !extracted_text.starts_with("<local-command-stdout>")
	                                        && !extracted_text.trim_start().starts_with("# AGENTS.md instructions")
	                                        && !extracted_text.trim_start().starts_with("<environment_context>")
	                                        && !extracted_text.trim_start().starts_with("<permissions instructions>")
	                                        && !extracted_text.contains("Warmup")
	                                    {
	                                        metadata.first_message = Some(extracted_text);
	                                        metadata.message_timestamp = entry.timestamp;
	                                    }
	                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    // Phase 2: Read file tail for last_message_timestamp (seek to last 32KB)
    metadata.last_message_timestamp = extract_last_timestamp_from_tail(path, file_size);
    
    metadata
}

/// Extracts the last timestamp by reading only the tail of the file
fn extract_last_timestamp_from_tail(path: &Path, file_size: u64) -> Option<String> {
    let file = fs::File::open(path).ok()?;
    let mut reader = BufReader::new(file);
    
    // Seek to last 32KB (or start if file is smaller)
    const TAIL_SIZE: u64 = 32 * 1024;
    let seek_pos = if file_size > TAIL_SIZE { file_size - TAIL_SIZE } else { 0 };
    reader.seek(SeekFrom::Start(seek_pos)).ok()?;
    
    // Skip partial first line if we seeked
    if seek_pos > 0 {
        let mut _skip = String::new();
        reader.read_line(&mut _skip).ok()?;
    }
    
    let mut last_timestamp: Option<String> = None;
    
    for line_result in reader.lines() {
        if let Ok(line) = line_result {
            if let Ok(entry) = serde_json::from_str::<JsonlEntry>(&line) {
                if entry.message.is_some() {
                    if let Some(timestamp) = entry.timestamp {
                        last_timestamp = Some(timestamp);
                    }
                }
            }
        }
    }
    
    last_timestamp
}

/// Extracts the first valid user message from a JSONL file
/// (Legacy function - calls optimized extract_session_metadata internally)
pub fn extract_first_user_message<P: AsRef<Path>>(jsonl_path: P) -> (Option<String>, Option<String>) {
    let metadata = extract_session_metadata(jsonl_path);
    (metadata.first_message, metadata.message_timestamp)
}

/// Extracts the timestamp of the last message from a JSONL file
/// (Legacy function - calls optimized extract_session_metadata internally)
pub fn extract_last_message_timestamp<P: AsRef<Path>>(jsonl_path: P) -> Option<String> {
    let path = jsonl_path.as_ref();
    let file_size = fs::metadata(path).map(|m| m.len()).unwrap_or(0);
    extract_last_timestamp_from_tail(path, file_size)
}

/// Extracts the model used in the session from a JSONL file
/// (Legacy function - reads only first 100 lines for efficiency)
pub fn extract_session_model<P: AsRef<Path>>(jsonl_path: P) -> Option<String> {
    let file = match fs::File::open(jsonl_path) {
        Ok(file) => file,
        Err(_) => return None,
    };

    let reader = BufReader::new(file);
    const MAX_LINES: usize = 100;
    let mut line_count = 0;

    for line in reader.lines() {
        line_count += 1;
        if line_count > MAX_LINES {
            break;
        }
        
        if let Ok(line) = line {
            if let Ok(entry) = serde_json::from_str::<Value>(&line) {
                if let Some(model_str) = entry.get("model").and_then(|m| m.as_str()) {
                    return Some(model_str.to_string());
                } else if let Some(message) = entry.get("message") {
                    if let Some(model_str) = message.get("model").and_then(|m| m.as_str()) {
                        return Some(model_str.to_string());
                    }
                }
            }
        }
    }

    None
}

/// Loads the JSONL history for a specific session
/// Also loads subagent messages from agent-*.jsonl files and merges them
pub fn load_session_history(session_id: &str, project_id: &str) -> Result<Vec<Value>, String> {
    log::info!(
        "Loading session history for session: {} in project: {}",
        session_id,
        project_id
    );

    let claude_dir = get_claude_dir().map_err(|e| e.to_string())?;
    let project_dir = claude_dir.join("projects").join(project_id);
    let session_path = project_dir.join(format!("{}.jsonl", session_id));

    if !session_path.exists() {
        return Err(format!("Session file not found: {}", session_id));
    }

    // Get file modification time as base timestamp
    let file_metadata = fs::metadata(&session_path)
        .map_err(|e| format!("Failed to read file metadata: {}", e))?;
    let base_time = file_metadata
        .modified()
        .unwrap_or_else(|_| SystemTime::now());

    let file =
        fs::File::open(&session_path).map_err(|e| format!("Failed to open session file: {}", e))?;

    let reader = BufReader::new(file);
    let mut messages = Vec::new();

    // Step 1: Load main session messages and build agentId -> tool_use_id mapping
    let mut agent_to_tool_use_id: std::collections::HashMap<String, String> = std::collections::HashMap::new();

    for line in reader.lines() {
        if let Ok(line) = line {
            if let Ok(json) = serde_json::from_str::<Value>(&line) {
                // Check for tool_result with agentId to build mapping
                if let Some(content) = json.get("message").and_then(|m| m.get("content")).and_then(|c| c.as_array()) {
                    for item in content {
                        if item.get("type").and_then(|t| t.as_str()) == Some("tool_result") {
                            // Get tool_use_id and agentId from toolUseResult
                            if let (Some(tool_use_id), Some(agent_id)) = (
                                item.get("tool_use_id").and_then(|t| t.as_str()),
                                json.get("toolUseResult").and_then(|r| r.get("agentId")).and_then(|a| a.as_str())
                            ) {
                                log::debug!("Found agentId mapping: {} -> {}", agent_id, tool_use_id);
                                agent_to_tool_use_id.insert(agent_id.to_string(), tool_use_id.to_string());
                            }
                        }
                    }
                }
                messages.push(json);
            }
        }
    }

    log::info!("Found {} agent-to-tool_use_id mappings", agent_to_tool_use_id.len());

    // Step 2: Load subagent messages from agent-*.jsonl files
    if !agent_to_tool_use_id.is_empty() {
        if let Ok(entries) = fs::read_dir(&project_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                    // Match agent-*.jsonl files
                    if file_name.starts_with("agent-") && file_name.ends_with(".jsonl") {
                        // Extract agentId from filename (e.g., "agent-aa740fde.jsonl" -> "aa740fde")
                        let agent_id = file_name
                            .strip_prefix("agent-")
                            .and_then(|s| s.strip_suffix(".jsonl"))
                            .unwrap_or("");

                        // Check if this agent belongs to our session
                        if let Some(tool_use_id) = agent_to_tool_use_id.get(agent_id) {
                            log::info!("Loading subagent file: {} for tool_use_id: {}", file_name, tool_use_id);

                            // Load subagent messages
                            if let Ok(file) = fs::File::open(&path) {
                                let reader = BufReader::new(file);
                                for line in reader.lines() {
                                    if let Ok(line) = line {
                                        if let Ok(mut json) = serde_json::from_str::<Value>(&line) {
                                            // Verify this subagent belongs to our session
                                            let subagent_session_id = json.get("sessionId").and_then(|s| s.as_str());
                                            if subagent_session_id == Some(session_id) {
                                                // Add parent_tool_use_id to link subagent messages to Task
                                                json["parent_tool_use_id"] = Value::String(tool_use_id.clone());
                                                messages.push(json);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Step 3: Sort messages by timestamp to maintain chronological order
    messages.sort_by(|a, b| {
        let ts_a = a.get("timestamp").and_then(|t| t.as_str()).unwrap_or("");
        let ts_b = b.get("timestamp").and_then(|t| t.as_str()).unwrap_or("");
        ts_a.cmp(ts_b)
    });

    // Add timestamps to historical messages that don't have them
    let messages_count = messages.len();
    for (i, message) in messages.iter_mut().enumerate() {
        let message_type = message.get("type").and_then(|t| t.as_str()).unwrap_or("");

        // Calculate timestamp for this message (5 second intervals, older messages get earlier timestamps)
        let time_offset = (messages_count - i - 1) as u64 * 5; // 5 seconds between messages
        let message_time = base_time - std::time::Duration::from_secs(time_offset);
        let timestamp_iso = DateTime::<Utc>::from(message_time).to_rfc3339();

        // Set appropriate timestamp fields based on message type, only if they don't exist
        match message_type {
            "user" => {
                if !message.get("sentAt").is_some() {
                    message["sentAt"] = Value::String(timestamp_iso.clone());
                }
            }
            "assistant" | "system" | "result" => {
                if !message.get("receivedAt").is_some() {
                    message["receivedAt"] = Value::String(timestamp_iso.clone());
                }
            }
            _ => {
                // For unknown types, add receivedAt
                if !message.get("receivedAt").is_some() {
                    message["receivedAt"] = Value::String(timestamp_iso.clone());
                }
            }
        }
    }

    log::info!("Loaded {} total messages (including subagent messages)", messages.len());
    Ok(messages)
}
